## Node.js


### Path
* path.normalize(path)
	* 规范化 path，并处理 '..' 和 '.' 片段。如果出现多个连续的路径分隔符则替换为单个分隔符。 末尾的多个分隔符会被保留。如果 path 是空字符串，则返回 '.'，表示当前工作目录。
* path.join([...paths])
	* 拼接path片段，生成规范化的路径
* path.basename(path[, ext])
	* 返回文件名
* path.extname(path)
	* 返回扩展名
* path.dirname(path)
	* 获取文件所在路径
* path.parse（path）
	* 解析路径返回对象
	```
		path.parse('/home/user/dir/file.txt');
		// 返回:
		// { root: '/',
		//   dir: '/home/user/dir',
		//   base: 'file.txt',
		//   ext: '.txt',
		//   name: 'file' }
	```
* path.format(obj)
	* 会从一个对象返回一个路径字符串,与parse刚好相反
* path.sep 当前环境下的路径分隔符
* path.delimiter 当前环境下的PATH分隔符
* __dirname,__filename总是返回文件的绝对路径
* process.cwd()总是返回执行node命令所在的文件夹



### Buffer
> 处理二进制数据流，实例类似整数数组，大小固定，C++代码在V8堆外分配物理内存

#### Buffer实例化
* Buffer.alloc(10)
	* 创建一个长度为10且用0填充的Buffer
* Buffer.alloc(1)
	* 创建一个长度为10，且用0x1填充的Buffer
* Buffer.allocUnsafe(10)
	* 创建一个长度为10并且没有初始化的Buffer，比alloc更快但是返回的实例可能包含旧数据，可以用fill()或者write()重写
* Buffer.from([1,2,3])
	* 创建一个包含[0x1,0x2,0x3]的Buffer
* Buffer.from('test')
	* 创建一个包含UTF-8字节[....]的Buffer

#### Buffer实用静态方法
* Buffer.byteLangth(string[, encoding]) 传入的字符串的字节数
* Buffer.isBuffer(obj) 传入的对象是否是一个Buffer实例对象
* Buffer.concat() 拼接Buffer实例对象
```
/ 用含有三个 `Buffer` 的数组创建一个单一的 `Buffer`。
const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(14);
const buf3 = Buffer.alloc(18);
const totalLength = buf1.length + buf2.length + buf3.length;

console.log(totalLength);
// 输出: 42

const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);

console.log(bufA);
// 输出: <Buffer 00 00 00 00 ...>
console.log(bufA.length);
// 输出: 42
```

#### Buffer实例对象常用的方法和属性
buf.length 获取该Buffer对象所占的字节数，与内容无关
buf.toString([encoding[, start[, end]]]) 根据 encoding 指定的字符编码将 buf 解码成字符串。
buf.fill() 用指定的 value 填充 buf。 如果没有指定 offset 与 end，则填充整个 buf
buf.equals() 内容是否一样，(同java中的obj.equals())
buf.indexOf()
buf.copy()


```
const StringDecoder = require('string_decoder').StringDecoder
const decoder = new StringDecoder('utf8');

const buf = Buffer.from('中文字符串！');

for(let i = 0 ; i < buf.length ; i+= 5){
	
	const b = Buffer.allocUnsafe(5);
	buf.copy(b,0,i);

	console.log(b.toString());

}

for(let i = 0 ; i < buf.length ; i+= 5){
	
	const b = Buffer.allocUnsafe(5);
	buf.copy(b,0,i);

	console.log(decoder.write(b));

}

```