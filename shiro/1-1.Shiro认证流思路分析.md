## Shiro认证流思路分析

1. 获取当前的Subject,调用SecurityUtils.getSubject();

2. 测试当前的用户是否已经被认证，，也就是说是否已经登录,调用Subject的isAuthentiated()
3. 若没有被认证，则将用户名和密码封装为UsernamePasswordToken对象
4. 执行登录：调用Subject的login(AuthenticationToken)方法
   1. UsernamePasswordTokens是AuthenticationToken的实现类

5. 自定义Realm方法，从数据表库中获取相应的记录，返回给shiro
   1. 实际上需要继承org.apache.shiro.realm.AuthenticatingRealm类
   2. 实现doGetAuthentication(AuthenticationToken)方法

6. 由shiro进行密码比对



## 密码的比对

通过AuthenticatingRealm的credentialsMather属性来进行密码的比对！



## MD5加密

替换当前Realm的credentialsMatcher属性，直接使用HashedCredentialsMatcher对象，并设置加密算法即可



## MD5盐值加密

在goGetAuthenticationInfo方法创建SimpleAuthenticationInfo对象的时候，需要使用SimpleAuthenticationInfo(principal,credentials, credentialsSalt, realmName);构造器

* 使用ByteSource credentialsSalt = ByteSource.Util.bytes(String str);来计算盐值，盐值需要唯一

* 使用 SimpleHash(hashAlgoritthmName, credentials, salt, hashIterations);计算盐值加密后的密码

## AuthenticationStrategy认证策略

> AuthenticationStrategy接口的默认实现

* FirstSuccessfulStategy 只要有一个Realm验证成功即可，只返回第一个Realm身份认证成功的认证信息，其他的忽略

* AtLeastOneSuccessfulStrategy：只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同，将返回所有Realm身份验证成功的认证信息

* AllSuccessfulStrstegy所有Realm验证成功才算成功，且返回所有Realm身份认证成功的认证信息，如果有一个不通过就失败

  > MoudlarRealmAuthenticator默认是AtLeastOneSuccessfulStrategy策略