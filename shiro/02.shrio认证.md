## 用户认证
### 1.Authentication：用户认证
> 验证用户是否合法，需要提交身份和凭证给shiro
![](http://md.yingxs.com/shiro2_01.png)
* Principals 用户的身份信息，是Subject的标识属性，能够唯一标识Subject。如电话号码，电子邮箱，身份证号码等
* Credentials 凭证：密码。是只被subject知道的密码值，可以是密码，也可以是数字证书等
* principals/Credentials 最常见的组合：用户名/密码。在shiro中通常使用UsernamePasswordToken来指明身份和凭证信息

### 2.在shiro中的用户认证流程
![](http://md.yingxs.com/shiro2_02.png)

### 3.代码实现
1. 新建java项目
2. 导入shiro相关的jar包
	```
	<dependencies>
		<dependency>
			<groupId>org.apache.shiro</groupId>
			<artifactId>shiro-all</artifactId>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-log4j12</artifactId>
		</dependency>
	</dependencies>
	```
3. 编写shiro的数据文件--配置
	* shiro.ini
	```
	[users]
	zhangsan=1111
	lisi=2222
	```
4. 编码测试
```
//1.创建SecurityManager工厂 读取相应的配置文件
Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");

//2.通过securtyManager工程获取SecurityManager的实例
SecurityManager securityManager = factory.getInstance();

//3.将securityManager对象设置到运行环境中
SecurityUtils.setSecurityManager(securityManager);

//4.通过SecurityUtils获取Subject
Subject subject = SecurityUtils.getSubject();


//5.加入登录的用户名和密码是zhangsan 和1111，这个地方的zhangsan和1111表示用户登录时输入的信息
//而shiro.ini文件中信息相当于数据库中存放的用户信息
UsernamePasswordToken token = new UsernamePasswordToken("zhangsan","1111");
//6.进行用户身份验证
subject.login(token);
//7.是否通过
if(subject.isAuthenticated()) {
	System.out.println("登录成功");
}else {
	System.out.println("用户名或密码不正确");
}

```

### 4.常见的异常以及处理
> 在认证过程中有一个父异常为:AuthenticationException

![](http://md.yingxs.com/shiro2_03.png)
该异常有几个子类，分别对应着不同的异常情况：
* DisabledAccountException 账户失效异常
* ExcessiveAttemptsException 尝试次数过多
* UnknownAccountException 用户不存在
* ExpiredCredentialsException 凭证过期异常
* IncorrectCredentialsException 凭证不正确异常

虽然shiro为每一种异常都提供了准确的异常类，但是在编写代码的过程中，应提示给用户的信息为模糊的，这样有助于安全

### 5.执行流程
1. 通过shiro相关API，创建SecurityManager，获取Subject的实例
2. 封装token信息
3. 通过subject.login(token)进行用户认证
	* Subject接收token，通过其实现类DelegatingSubject将token委托给SecurityManager来完成认证，SecurityManager是通过实现类DefaultSecurityManager完成相关的认证，由DefaultSecurityManager中login来完成认证，在login中调用了该类中的authentiacte()来完成认证，该方法是由AuthentiactingSecurityManager完成的，在该类的authenticate()中，通过调用authenticator(认证器)来完成工作，Authenticator是由其默认实现类ModularRealmAuthenticator来完成认证，通过其中的doAuthenticate方法获取Realms信息，如果是单realm直接将token和realm中的数据进行比较，判断是否认证成功，如果是多realm，那么需要通过Authentication Strategy来完成认证工作，如果失败就会抛出异常

4. 通过subject.isAuthenticated来判断认证是否成功