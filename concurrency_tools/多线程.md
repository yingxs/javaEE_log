

## 实现多线程的方式有几种？

#### Oracle官网的说法：

* 实现Runnable接口，最终调用target.run();
* 继承Thread类,整个run()都被重写

通常我们可以分为两类，Oracle也是这么说的，但准确的将，创建线程只有一种方式那就是构造Thread类，而实现线程执行单元有两种方式

* 方法一：实现Runable接口的run方法，并把Runnable实例传给Thread类
* 方法二：重写Thread的run方法(继承Thread类)

## 提高能力的途径

#### 宏观上：

1. 能力的提升并不是靠工作年限，有的人工作了5年技术却还是只懂皮毛
2. 要有强大的责任心，不放过任何bug，找到原因去解决，这就是提高
3. 主动：永远不会觉得自己的事件多余，重构，优化，学习，总结等
4. 敢于承担：虽然这个技术难题以前没碰到过，但是在一定的了解之后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程，进步是飞速的
5. 关心产品，关心业务，而不只是写代码

#### 微观上：

1. 经典书籍，Java并发编程实战，自顶向下计算机网络
2. 看官方文档
3. 英文搜google和stackoverflow
4. 动手，实践写demo，尝试用到项目中
5. 不理解的参考多个书本，综合判断
6. 学习开源项目，分析源码，学习synchronized原理，反编译，看cpp代码

## 如何了解技术领域的最新动态

* 高质量的固定途径
* 订阅技术论坛
* 公众号

## 如何在业务开发中成长

偏业务方向：把复杂的业务进行合理的抽象，金融，搜索，电商

偏技术方向：中间件，消息队列

两个25%理论



## 线程停止

### 原理

​	使用interrput来通知，而不是强制停止

### 实践

* 情况一：run方法中没有sleep或者wait方法时停止线程

  ```java
  /**
   * run方法中没有sleep或者wait方法时，停止线程
   */
  public class RightWayStopThreadWithoutSleep implements Runnable {
  
  
      @Override
      public void run() {
          int num = 0;
          while(num <= Integer.MAX_VALUE / 2 && !Thread.currentThread().isInterrupted() ) {
              if (num % 10000 == 0) {
                  System.out.println(num+"是10000的倍数");
              }
              num++;
          }
          System.out.println("任务运行结束了");
      }
  
  
      public static void main(String[] args) throws InterruptedException {
          Thread thread = new Thread(new RightWayStopThreadWithoutSleep());
          thread.start();
          Thread.sleep(2000);
          thread.interrupt();
      }
  
  }
  ```

* 情况二：带有sleep的中断线程,线程休眠时，收到中断信号，会抛出异常来响应中断

  ```java
  
  /**
   * 带有sleep的中断线程的写法
   * 线程休眠时，收到中断信号，会抛出异常来响应中断
   */
  public class RightWayStopThreadWaitSleep {
  
  
      public static void main(String[] args) throws InterruptedException {
          Runnable runnable = ()->{
              int num = 0;
  
              try {
                  while (num <= 300 && !Thread.currentThread().isInterrupted()) {
                      if (num % 100 ==0) {
                          System.out.println(num+"是100的倍数");
                      }
                      num++;
                  }
  
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
  
  /*
              while (num <= 300 && !Thread.currentThread().isInterrupted()) {
                  if (num % 100 ==0) {
                      System.out.println(num+"是100的倍数");
                  }
                  num++;
              }
              try {
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
  */
  
          };
  
          Thread thread = new Thread(runnable);
          thread.start();
          Thread.sleep(500);
          thread.interrupt();
  
      }
  
  }
  
  ```

* 情况三：如果在执行过程中，每次循环都会调用sleep或wait等方法，那么不需要每次迭代都检查是否被中断，因为sleep会帮我们响应中断

  ```java
  
  /**
   * 如果在执行过程中，每次循环都会调用sleep或wait等方法，那么不需要每次迭代都检查是否被中断
   * 因为sleep会帮我们响应中断
   */
  public class RightWayStopThreadWithSleepEveryLoop {
  
      public static void main(String[] args) throws InterruptedException {
          Runnable runnable = ()->{
              int num = 0;
              try {
                  while (num <= 10000) {
                      if (num % 100 ==0) {
                          System.out.println(num+"是100的倍数");
                      }
                      num++;
  
                          Thread.sleep(10);
  
                  }
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
  
          };
  
          Thread thread = new Thread(runnable);
          thread.start();
          Thread.sleep(5000);
          thread.interrupt();
  
      }
  
  }
  
  ```

* 自动清除中断信号

  ```java
  /**
   * 如果while里面放try/catch,会导致中断失效
   * sleep会清除终端标记
   */
  public class CantInterrupt {
  
      public static void main(String[] args) throws InterruptedException {
          Runnable runnable = ()->{
              int num = 0;
              while (num <= 10000) {
                  if (num % 100 == 0) {
                      System.out.println(num+"是100的倍数");
                  }
                  num++;
                  try {
                      Thread.sleep(10);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          };
  
          Thread thread = new Thread(runnable);
          thread.start();
          Thread.sleep(5000);
          thread.interrupt();
      }
  }
  
  ```

### 实际开发中的最佳实践

* 优先选择：传递中断，是指方法签名上抛出异常
* 不想或无法传递：恢复中断，人为的手动恢复,在catch中使用Thread.currentThread().interrupt();恢复中断，以便于在后续执行中依然能够检查到刚才发生了中断
* 不应屏蔽中断

### 响应中断的方法总结列表

* Object.wait()
* Thread.sleep()
* Thread.join()
* java.util.concurent.BlockingQueue.take()/put(E e)  阻塞队列
* java.util.concurrent.locks.Lock.lockInterruptibly() 锁
* java.util.concurrent.CountDownLatch.await()
* java.util.concurrent.CyclicBarrier.await()
* java.util.concurrent.Exchanger.exchange(V)
* java.nio.channels.InterruptibleChannel相关方法
* java.nio.channels.Selector相关方法

### 错误的停止方法

* 被弃用的stop,suspend,resume方法
  * stop会导致线程运行一半突然停止，没办法完成一个基本单位的操作，会造成脏数据
* 用valatile设置boolean标记位

### 注意

* static boolean interrupted() 检测当前线程是否被中断，会清除线程中断信号

* boolean isInterupted() 检测当前线程是否被中断，不会清除中断信号

* Thread.interrupted()的目的对象为当前线程

* interrupted()方法只判断当前线程

  ```java
  /**
   * Thread.interrupted()方法的目标对象是"当前线程"，而不管本方法来自于哪个对象
   */
  public class RightWayInterrupted {
  
      public static void main(String[] args) {
          Thread threadOne = new Thread(new Runnable() {
              @Override
              public void run() {
                  for(;;){}
              }
          });
  
          threadOne.start();
          threadOne.interrupt();
  
          //获取中断标记
          System.out.println(threadOne.isInterrupted());
          //获取中断标记并重置
          System.out.println(threadOne.interrupted());
          //获取中断标记并重置
          System.out.println(Thread.interrupted());
          //获取中断标记
          System.out.println(threadOne.isInterrupted());
          
      }
  
  }
  ```

  ### 如何停止线程？

  1. 原理：用interrupt来请求，好处
  2. 想停止线程，要请求方，被停止方，子方法被调用方相互配合
  3. 错误的方法：stop/suspend已废弃，volatile的bolean无法处理长时间阻塞

  ### 如何处理不可中断的阻塞？ 

  ​	特定情境使用特定的可以响应中断的方法，优先使用可以响应中断的方法


## 线程状态

### 六种状态

1. New 新建线程,做了一些准备工作，还未start()

2. Runnable(可运行的)  新线程start()之后，可能正在执行，也可能没有执行

3. Blocked synchronized修饰的代码，没抢到锁，等待状态，仅限于synchronized关键字

4. Waiting 

5. TimedWaiting

6. Terminated

   ![](http://img.yingxs.com/dxc1.jpg)

   一般而言，把Blocked(被阻塞)，Waiting(等待)，Timed_waiting(计时等待)都称为阻塞状态，不仅仅是Blocked



## Thread和Object的重要方法

1. 为什么线程通信方法wait(),notify()和notifyAll()被定义在Object类中？而sleep定义在Threa类里？
2. 用三种方式实现生产者模式
3. join和sleep和wait期间线程的状态分别是什么？为什么？

![](http://img.yingxs.com/dxc2.png)

### 1.wait,notify,notifyAll发方法详解

> 作用或用法：阻塞，唤醒，遇到中断
>
> 原理，注意点

执行wait()方法的时候，必须拥有这个对象的monitor锁，调用者进入阻塞状态，直到一下四种情况，才会被唤醒：

1. 另外一个线程调用这个对象的notify()方法且刚好唤醒的是本线程
2. 另外一个线程调用这个对象的botifyAll方法
3. 过了wait(long timeout)规定的事件，如果传入0就是永久等待
4. 线程自身调用了interrupt()

>  wait，notify需要在synchronized关键字的保护下执行

wait()执行的之前，必须在Synchronized关键字保护中执行，进入Synchronized说明拿到了锁，而执行wait会释放这把锁，且该线程进入阻塞状态

注意：

 	1. 用之前必须先拥有monitor锁
 	2. 属于Object类
 	3. 类似功能的Condition
 	4. 同时持有多个锁的情况

* wait，notify实现生产者消费者模式

```java
/**
 * 用wait/notify来实现生产者消费者
 */
public class ProducerConsumerModel {

    public static void main(String[] args) {

        EventStorage eventStorage = new EventStorage();
        Producer producer = new Producer(eventStorage);
        Consumer consumer = new Consumer(eventStorage);

        new Thread(producer).start();
        new Thread(consumer).start();

    }

}

class Producer implements Runnable {

    private EventStorage storage;

    public Producer (EventStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for (int i = 0 ; i<100 ; i++) {
            storage.put();
        }
    }
}

class Consumer implements Runnable {

    private EventStorage storage;

    public Consumer (EventStorage storage) {
        this.storage = storage;
    }
    
    @Override
    public void run() {
        for (int i = 0 ; i<100 ; i++) {
            storage.take();
        }

    }
}


class EventStorage {
    private  int maxSize;
    private LinkedList<Date> storage;

    public EventStorage(){
        maxSize = 10;
        storage = new LinkedList<>();
    }

    public synchronized  void put ()   {

        while (storage.size() == maxSize) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        storage.add(new Date());
        System.out.println("仓库有了"+storage.size()+"产品");
        notify();

    }

    public synchronized  void take()   {
        while (storage.size() == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("拿到了"+storage.poll()+"，现在仓库还剩下"+storage.size()+"个");
        notify();
    }
}
```

* 两个线程交替打印0-100奇数偶数

```java

/**
 * 两个线程交替打印0-100的奇数和偶数
 * synchronized关键字实现
 */
public class WaitNotifyPrintOddEvenSyn {


    private static int count;

    private final static  Object lock = new Object();


    /**
     * 新建两个线程
     * 一个只处理偶数，第二个只处理奇数 用位运算
     * 用synchronized来 通信
     */

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (count < 100) {
                    synchronized (lock) {
                        if ( (count & 1) == 0) {
                            System.out.println(Thread.currentThread().getName()+":"+count++);
                        }
                    }
                }
            }
        },"偶数").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                while (count < 100) {
                    synchronized (lock) {
                        if ( (count & 1) == 1) {
                            System.out.println(Thread.currentThread().getName()+":"+count++);
                        }
                    }
                }
            }
        },"奇数").start();
    }
}

```

```java

/**
 * 两个线程交替打印0-100的奇数和偶数
 * 用wait和notify实现
 */
public class WaitNotifyPrintOddEveWait {
    /*
    1.拿到锁就打印
    2.打印完，唤醒另一个线程，自己休眠
     */

    private static int count;
    private static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lock) {
                    while (count <= 100) {
                        System.out.println(Thread.currentThread().getName()+":"+count++);
                        try {
                            lock.notify();
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lock) {
                    while (count <= 100) {
                        System.out.println(Thread.currentThread().getName()+":"+count++);
                        try {
                            lock.notify();
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }).start();
    }

}

```

* 为什么wait()需要在同步代码块中使用，而sleep()不需要？

​	主要是为了让通信变得可靠，防止死锁和永久的等待，避免线程切换导致执行顺序错乱，而sleep()本身就是对自己线程的，与其他线程关系不大

* 为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？

​	主要是因为wait，notify是锁级别的操作，锁是绑定到对象中并不是线程中

* wait方法是Object对象的，那么调用Thread.wait会怎样？

​	我们可以将Thread的实例当做一个普通的锁对象，但是Thread比较特殊，他在线程退出时候，会自动调用notfiy，会让我们设计的流程受到影响



### 2.sleep方法详解

> 作用：只想让线程再预期的期间执行，其他时候不要占用CPU资源

sleep不释放锁，包括synchronzied和lock，和wait不同

#### 响应中断

1. 抛出InterruptedException

2. 清楚中断状态

   ```java
   /**
    * 每隔1秒钟输出当前时间，被中断，观察
    * Thread.sleep()
    * TimeUnit.SECONDS.sleep()
    */
   public class SleepInterrupted implements Runnable {
   
       @Override
       public void run() {
           for (int i = 0 ; i < 10 ; i++) {
               System.out.println(new Date());
               try {
                   //休眠3小时25分23秒
                   TimeUnit.HOURS.sleep(3);
                   TimeUnit.MINUTES.sleep(25);
                   TimeUnit.SECONDS.sleep(23);
               } catch (InterruptedException e) {
                   System.out.println("我被中断了！");
                   e.printStackTrace();
               }
           }
       }
   
       public static void main(String[] args) throws InterruptedException {
           Thread thread = new Thread(new SleepInterrupted());
           thread.start();
           Thread.sleep(6500);
           thread.interrupt();
       }
   
   
   }
   
   ```

   sleep方法可以让线程进入Waiting状态；并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清楚中断状态

* wait/notify和sleep的异同
  * 相同点：会阻塞，可以响应中断
  * 不同：同步方法中，释放锁，指定时间，所属类

### 3.join方法

> 作用：新的线程加入我们之前，所以我们要等他执行完之后再执行，例如main等待thread1执行完毕，等待加载资源等场景

```java
/**
 * join期间被中断的是主线程
 * join期间主线程状态为waiting
 */
public class JoinInterrupt {

    public static void main(String[] args)  {

        Thread mainThread = Thread.currentThread();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    mainThread.interrupt();
                    Thread.sleep(5000);
                    System.out.println("Thread1 finished");
                } catch (InterruptedException e) {
                    System.out.println("子线程中断");

                }
            }
        });

        thread1.start();
        System.out.println("等待子线程执行完毕");
        try {
            thread1.join();
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName()+"主线程被中断了");
            //主线程中断时 子线程也被中断，防止数据错乱
            thread1.interrupt();
        }
        System.out.println("子线程运行完毕");
    }
}

```

* join的功能封装：CountDownLatch或CyclicBarrier类

* join的等价实现

```
/**
 * join底层原理为wait实现
 * join的等价实现
 */
public class JoinPrinciple {

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread1 finished");
            }
        });


        thread.start();
        System.out.println("开始等待子线程运行完毕");
//        thread.join();
        synchronized (thread) {
            thread.wait();
        }
        System.out.println("所有子线程执行完毕");
    }
}
```

### 4.yield方法详解

> 作用：释放自己的CPU时间片，状态依然是Runnable，不会释放锁，JVM不保证遵循

与sleep区别：是否随时可能再次被调度

## 线程的各个属性

> 什么时候需要设置守护线程？
>
> 应该如何应用线程优先级来帮助程序运行？有哪些禁忌？
>
> 不同操作系统如何处理优先级问题？

![](http://img.yingxs.com/dxc3.png)

### 线程ID

​	唯一，自增，无法修改，用于JVM标识线程，JVM默认会创建其他线程

### 守护线程

> 给用户线程提供服务，比如垃圾回收器

* 线程类型默认继承自线程
* 被谁启动
* 不影响JVM退出
* 守护线程和普通线程区别
  * 整体无区别
  * 唯一区别在于是否影响JVM的退出
  * 普通线程是执行我们规定的任务，守护线程是为我们普通线程提供服务的

### 线程优先级

> 10个级别，默认为5

程序设计不应该依赖于优先级：

* 不同的操作系统不一致
* 优先级会被操作系统改变



## 线程的未捕获异常UncaughException的处理

### 为什么需要UncaughtExceptionHandler？

* 主线程可以轻松发现 异常，子线程却不行
* 子线程异常无法用传统方法捕获

实现UncaughtExceptionHandler

* 给程序统一设置
* 给每个线程单独设置
* 给线程池设置

```java
public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {

    private String name;

    public MyUncaughtExceptionHandler(String name) {
        this.name = name;
    }

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("线程异常，终止"+","+t.getName()+","+e);
        System.out.println(name+" 捕获了异常："+t.getName()+" 异常"+e);
    }

}
```

```java
/**
 * 使用自己的UncaughtExceptionHandler
 */
public class UseOwnUncaughtExceptionHandler {

    public static void main(String[] args) throws InterruptedException {

        Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler("线程异常捕获器"));


        new Thread(new Runnable() {
            @Override
            public void run() {
                throw new RuntimeException();
            }
        },"MyThread-1").start();
        Thread.sleep(300);
        new Thread(new Runnable() {
            @Override
            public void run() {
                throw new RuntimeException();
            }
        },"MyThread-1").start();
        Thread.sleep(300);
        new Thread(new Runnable() {
            @Override
            public void run() {
                throw new RuntimeException();
            }
        },"MyThread-1").start();
        Thread.sleep(300);
        new Thread(new Runnable() {
            @Override
            public void run() {
                throw new RuntimeException();
            }
        },"MyThread-1").start();
        Thread.sleep(300);
    }

}

```

## 线程安全

> 一共有哪几类线程安全问题？
>
> 哪些场景需要额外注意线程安全问题？
>
> 什么是多线程带来的上下文切换？

### 什么是线程安全？

​	当多个线程访问一个对象时，如果不用考虑这些线程再运行时环境下的调度和交替执行，也不需要进行额外的同步或者在调用方进行任何其他协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的

​	不管业务中遇到怎么样的多个线程访问某对象或某方法的情况，在编写这个业务逻辑的时候，都不需要做任何额外的处理，程序也可以正常运行，就可以称为线程安全



### 什么情况下会出现线程安全问题，怎么避免？

* 运行结果错误：a++多线程下出现消失的请求现象
* 活跃性问题：死锁，活锁，饥饿
* 对象发布和初始化的时候的安全问题

### 线程安全三种情景

* 运行结果错误

  ```java
  
  /**
   * 运行结果出错
   * 计数不准确，找出具体出错的位置
   */
  public class MultiThreadsError implements  Runnable {
      
      static MultiThreadsError instance =  new MultiThreadsError();
  
      int index = 0;
  
      static AtomicInteger realIndex = new AtomicInteger();
      static AtomicInteger wrongCount = new AtomicInteger();
  
      static volatile CyclicBarrier cyclicBarrier1 = new CyclicBarrier(2);
      static volatile CyclicBarrier cyclicBarrier2 = new CyclicBarrier(2);
  
  
       boolean[] marked = new boolean[1000000000];
  
      public static void main(String[] args) throws InterruptedException {
          Thread thread1 = new Thread(instance);
          Thread thread2 = new Thread(instance);
          thread1.start();
          thread2.start();
          thread1.join();
          thread2.join();
          System.out.println("表面上结果是："+instance.index);
          System.out.println("真正运行的次数是："+realIndex.get());
          System.out.println("错误次数："+wrongCount.get());
      }
  
      @Override
      public void run() {
          marked[0] = true;
  
          for (int i = 0; i < 1000000 ; i++) {
              try {
                  cyclicBarrier2.reset();
                  cyclicBarrier1.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } catch (BrokenBarrierException e) {
                  e.printStackTrace();
              }
              index++;
              try {
                  cyclicBarrier1.reset();
                  cyclicBarrier2.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } catch (BrokenBarrierException e) {
                  e.printStackTrace();
              }
              realIndex.incrementAndGet();
              synchronized (instance) {
  
                  if (marked[index] && marked[index-1]) {
                      System.out.println("发生错误:"+index);
                      wrongCount.incrementAndGet();
                  }
                  marked[index] = true;
              }
  
          }
  
      }
  }
  
  ```

* 死锁

  ```java
  
  /**
   * 第二种线程安全问题 死锁
   */
  public class MyliThreadError implements Runnable {
  
      int flag = 1;
  
      static Object o1 = new Object();
      static Object o2 = new Object();
  
      public static void main(String[] args) {
          MyliThreadError r1 = new MyliThreadError();
          MyliThreadError r2 = new MyliThreadError();
          r1.flag = 1;
          r2.flag = 0;
  
          new Thread(r1).start();
          new Thread(r2).start();
  
      }
  
      @Override
      public void run() {
          System.out.println("flag = "+flag);
          if (flag == 1) {
              synchronized (o1) {
                  try {
                      Thread.sleep(500);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  synchronized (o2) {
                      System.out.println("1");
                  }
  
              }
          }
          if (flag == 0) {
              synchronized (o2) {
                  try {
                      Thread.sleep(500);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  synchronized (o1) {
                      System.out.println("0");
                  }
  
              }
          }
  
      }
  }
  
  ```

* 对象发布、溢出和初始化的时候的安全问题

  * 溢出：
    * 方法返回一个priae对象，解决办法：返回一个副本
    * 还未完成初始化（构造函数还没执行完毕）就把对象提供给外界（使用工厂模式列解决），比如：
      * 在构造函数中未初始化完毕就this赋值
      * 隐式溢出-注册监听事件
      * 构造函数中运行线程



### 各种需要考虑线程安全的情况呢

* 访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等
* 所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题：read-modify-write(先读后写) 、check-then-act(先检查再执行)
* 不同的数据之间存在捆绑关系的时候
* 我们使用其他类的时候，如果对象没有声明自己是线程安全的，我们需要处理

### 多线程导致的性能问题

#### 为什么多线程会带来线程问题？

* 调度：上下文切换，缓存开销，抢锁和IO会导致密集的上下文切换
* 协同：内存同步



## Java内存模型

### JVM内存结构 VS Java内存模型 VS Java对象模型

* JVM内存结构，和Java虚拟机的运行时区域有关

  ![](http://img.yingxs.com/dxc4.png)

* Java内存模型，和Java的并发编程有关

* Java对象模型，和Java对象在虚拟机中的表现形式有关

  * Java对象自身的存储模型
  * JVM会给这个类床架一个instanceKlass，保存在方法区，用来在JVM层表示该Java类
  * 当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据

  ![](http://img.yingxs.com/dxc5.png)


### JAVA内存模型(JMM)

​	Java Momory Model,为什么需要JMM，在C语言中不存在内存模型的概念，依赖处理器，不同处理器的结果不一致，无法保证并发安全，在这种情况下我们急需要一个标准，让多线程运行的结果可预期，是一组规范。如果没有这样的一个JMM内存模型来规范，那么很有可能经过不同的JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一致，那是很大的问题

​	volatile，synchronized，lock等的底层原理都是JMM，如果没有JMM，那就需要我们自己指定什么时候用内存栅栏，那是相当麻烦的，JMM让我们只需要同步工具和关键字就可以开发并发程序

#### 重排序

​	在线程内部的两行代码的实际执行顺序和带啊在Java文件中的顺序不一致，代码指令并不是阉割按照代码语句顺序执行的，它们的顺序被改变了，这就是重排序。

​	![](http://img.yingxs.com/dxc6.png)

​	重排序明显提高了处理速度

重排序的三种情况：

* 编译器优化：包括JVM，JIT编译器等
* CPU指令重拍：就算编译器不发生重排，CPU也可能对指令进行重排
* 内存的“重排序” ：线程A的修改线程B却看不到，引出可见性问题

#### 可见性

> 主内存和线程本地内存的更新不同步 导致的可见性问题

解决：volatile，强制每次读取的值都是线程修改过的最新的值



为什么会有可见性问题？

​	![](http://img.yingxs.com/dxc7.png)

CPU与主存的速度有较大差异，因此它们之间存在多级缓存，从底向上，每一次层缓存的容量都在逐渐缩小，但速度却在加快，但因为CPU拿的不是主存的内容，出现可见性问题

CPU有多级缓存，导致读的数据过期

* 告诉缓存的容量比主内存小，但是速度比主存块，所以在主存和CPU之家就多了Cache层
* 线程之间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的
* 如果所有核心都只用一个缓存，俺么也就不存在内存可见性问题了
* 每个核心都会讲自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中，所以会导致有些核心读取的值是一个过期的值

### JMM的抽象：主内存和本地内存

> Java的可见性解决方案

 主内存和本地内存

* Java作为高级语言，屏蔽了这些底层细节，用JMM定义了一套读写内存数据的规范，虽然我们不再关心一级缓存和二级缓存的问题，但是，JMM抽象了主内存和本地内存的概念

* 这里说的本地内存并不真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器，一级缓存，二级缓存的抽象

  ![](http://img.yingxs.com/dxc8.png)


JMM对于主内存和本地内存的规定：

1. 所有的变量都储存在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容都是主内存的拷贝
2. 线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后再同步到主内存中
3. 主内存是多个线程共享的，但线程不共享工作内幕才能，如果线程间需要通信，必须借助主内存中转来完成
4. 所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题

​	

### happens-before

什么是happens-before？

* happens-before规则是用来解决可见性问题的：在时间上，动作A发生在动作B之前，B保证能看见A，这就是happens-before
* 两个操作可以用happens-before来确定它们的执行顺序：如果一个操作happens-before与另一个操作，那么我们说第一个操作对于第二个操作时可见的

什么不是happens-before？

* 两个线程没有相互配合的机制，所以代码X和Y的执行结果并不能保证总被对方看到，这就不具备happens-before

happens-before规则有哪些？

1. 单线程规则
2. 锁操作（synchronized和Lock）*
3. volatile变量 *
4. 线程启动
5. 线程join
6. 传递性：如果hb(A,B),而且hb(B,C),那么可以推出hb(A,C)
7. 中断：一个线程或其他interrupt时，那么检测中断(isINterrupted)或者抛出InterruptedException一定能看到
8. 构造方法：对象构造方法的最后一行指令happens-before于finalize()方法的第一条指令
9. 工具类的happens-before原则
   1. 线程安全的容器get一定能看到在此之前的put()操作
   2. CountDownLatch
   3. Semaphore
   4. Future
   5. 线程池
   6. CyclicBarrier

### volatile关键字

> volatile是一种同步机制，比synchronized或者Lock相关类更清凉，因为使用volatile并不会发生上下文切换等开销很大的行为
>
> 如果一个变量被修饰成volatile,那么JVM就知道了这个变量可能会被并发修改
>
> 开销小，相应的能力夜宵，虽然说volatile是用来同步的保证线程安全的，但是volatile做不到synchronzied那样的原子保护，volatile仅仅在很有限的场景下才能发挥作用

适用场景：

* boolean flag,如果一个共享变量自始至终只被各个线程赋值，而没有其他操作，那么就可以用volatile来代替synchrnized或者用原子变量代替，因为赋值自身是具有原子性的，而volatile又保证了可见性，所以就足以保证线程安全

* 作为刷新之前变量的触发器

两点作用：

* 可见性：读一个voliatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个volatile属性的值会立即刷入到主内存
* 禁止指令重排序优化，解决单例双重锁乱序问题

volatile和synchronized

​	volatile可以看做是一个轻量级的synchronized，实现的作用是类似的，是用来保证线程安全的；只不过volatile的使用场景比较窄。

volatile小结：

* volatile的读写操作都是无锁的，他不能替代synchronized因为它没有提供原子性和互斥性，因为无锁，不需要花费时间再获取锁和释放锁上，所以它是低成本的
* volatile只能作用域属性，我们用volatile修饰属性，这样编译器就不会对这个属性做指令重排序
* volatile提供了可见性，任何一个线程对该属性的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取
* volatile提供了happens-before保证，对volatile变量v的写入bappens-bufore所有其他线程后续对v的读操作
* volatile可以使得long和double的赋值是原子的

能保证可见性的措施：

​	除了volatile可以让变量保证可见性之外，synchronized,Lock,并发集合，Thread.join()，Threa.start()等都可以保证可见性，具体可见happens-before原则的规定

对synchronized可见性的正确理解：

* synchronized不仅保证了原子性，还保证了可见性
* synchronized不仅让被保护的代码安全，synchronized之前的代码也都可被看到

### 原子性

> 一系列的操作，要么全部只能成功，要么全部不执行或执行失败，不会出现执行一半的情况，是不可分割的

Java中的院子操作有哪些？

* 除long,double之外的基本类型(int,byte,boolean,short,char,float)的赋值操作
* 所有引用的的赋值操作
* java.concurent.Atomic.*包中所有类的原子操作

long和double的原子性

​	官方文档：对于64位的值的写入，可以分为两个32位的操作进行写入，可能会发生读写错误，可以使用volatile解决

​	在32位的JVM上，long和double的操作不是原子的，但是64位的JVM上是原子的



## 常见问题

>  JMM应用实例：实例模式的8种写法、单例和并发的关系

为什么需要单例：

1. 节省内存和计算
2. 保证结果正确
3. 方便管理

单例模式的适用场景：

1. 无状态的工具类
2. 全局信息类(统计，资源)

#### 单例模式8种写法

* 饿汉：简单，但是没有lazy loading

```java
/**
 * 饿汉式(静态常量) 可用
 * 类加载时由JVM完成实例化，保证线程安全
 */
public class Singleton1 {
    private final static Singleton1 INSTANCE = new Singleton1();
    private Singleton1() {
        System.out.println("Singleton1实例化");
    }
    public static Singleton1 getInstance() {
        return INSTANCE;
    }
}

/**
 * 饿汉式(静态代码块) 可用
 * 类加载时由JVM完成实例化，保证线程安全
 */
public class Singleton2 {
    private final static Singleton2 INSTANCE;
    static {
        INSTANCE = new Singleton2();
    }
    private Singleton2() {
        System.out.println("Singleton2实例化");
    }
    public static Singleton2 getInstance() {
        return INSTANCE;
    }
}

```

* 懒汉：有线程安全问题

```
/**
 * 懒汉式 - 懒加载 (线程不安全)
 */
public class Singleton3 {
    private static Singleton3 instance;
    private Singleton3(){
        System.out.println("Singleton3实例化");
    }
    public static Singleton3 getInstance() {
        if (instance == null) {
            instance = new Singleton3();
        }
        return instance;
    }
}


/**
 * 懒汉式 - 懒加载 (线程安全) 不推荐 效率低
 */
public class Singleton4 {
    private static Singleton4 instance;
    private Singleton4(){
        System.out.println("Singleton4实例化");
    }
    public static synchronized Singleton4 getInstance() {
        if (instance == null) {
            instance = new Singleton4();
        }
        return instance;
    }
}

```

* 静态内部类

```
/**
 * 静态内部类方式，可用
 *
 * 线程安全+懒加载
 */
public class Singleton7 {
    private Singleton7(){
        System.out.println("Singleton7实例化");
    }
    private static class SingletonInstance {
        private static final Singleton7 INSTANCE = new Singleton7();
    }
    public static Singleton7 getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```

* 双重检查 : 炫技

```
/**
 * 双重检查
 * 线程安全;延迟加载；效率较高
 *
 * 为什么要用volatile?
 *  1.新建对象实际上有三个步骤 建立空对象，属性赋值，返回引用
 *  2.重排序可能会带来空指针异常
 *  3.防止重排序，可见性
 */
public class Singleton6 {
    private volatile static Singleton6 instance;
    private Singleton6(){
        System.out.println("Singleton6实例化");
    }
    public static Singleton6 getInstance() {
        if (instance == null) {
            synchronized (Singleton6.class) {
                if (instance == null) {
                    instance = new Singleton6();
                }
            }
        }
        return instance;
    }
}

```

* 枚举：最好 ;线上
  * 写法简单，线程安全有保障，懒加载
  * 避免反序列化破坏单例

#### 什么是Java内存模型？

​	  重排序的例子和好处  可见性：JMM对内存抽象，happen-before原则，volatile关键字 使用场合和synchronized的关系，synchronized的原理 保证原子性 可见性，原子性

#### volatile和synchronized的异同？

​	volatile是轻量级的synchronized，volatile开销小，责任小

#### 什么是原子操作？Java中哪些原子操作？生成对象的过程是不是原子操作？

​	生成对象不是原子操作，1.新建一个空的对象 2.把对象的引用指向p 3.执行对象的构造函数

#### 什么是内存可见性？

![](http://img.yingxs.com/dxc7.png)

#### 64位double和long写入的时候是原子的吗？



## 死锁

> 1.写一个必然死锁的例子
>
> 2.发生死锁必须满足的条件？
>
> 3.如何定位死锁？
>
> 4.有哪些解决死锁的策略？
>
> 5.经典的哲学家就餐的问题？
>
> 6.实际工程中如何避免死锁
>
> 7.什么是活跃性问题？活锁、饥饿、死锁有什么区别？

### 什么是死锁？

* 发生在并发中

* 互不相让：当两个线程相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续进行，导致程序陷入无尽的阻塞，这就是死锁。

  ![](http://img.yingxs.com/dxc9.png)

* 多个线程造成死锁的情况：如果多个下城之间的依赖关系是环形，存在环路的锁的依赖关系，那么也可能会发生死锁。

  ![](http://img.yingxs.com/dxc10.png)


### 死锁的影响

​	死锁的影响在不同的系统中影响是不一样的，这取决于系统对死锁的处理能力

在数据库中，检测并放弃事务；在JVM中不会自动处理

* 几率不高但是危害很大
* 一旦发生，多是高并发的场景，影响用户多
* 整个系统崩溃，子系统崩溃，性能降低
* 压力测试无法找出所有潜在的死锁

### 发生死锁的例子

```java
public class MustDeadLock implements Runnable {

    int flag = 1;

    static Object o1 = new Object();
    static Object o2 = new Object();


    public static void main(String[] args) {
        MustDeadLock r1 = new MustDeadLock();
        MustDeadLock r2 = new MustDeadLock();
        r1.flag = 1;
        r1.flag = 0;

        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);
        t1.start();
        t2.start();
    }

    @Override
    public void run() {

        System.out.println("flag= "+flag);

        if (flag == 1) {
            synchronized (o1) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    System.out.println("线程1成功拿到两把锁");
                }
            }

        }

        if (flag == 0) {
            synchronized (o2) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println("线程2成功拿到两把锁");
                }
            }

        }

    }
}

```
```
jstack pid 



Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x000000000377b2a8 (object 0x00000000d695bfe8, a java.lang.Object),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x00000000198f8488 (object 0x00000000d695bfd8, a java.lang.Object),
  which is held by "Thread-1"

Java stack information for the threads listed above:
===================================================
"Thread-1":
        at com.yingxs.deadlock.MustDeadLock.run(MustDeadLock.java:36)
        - waiting to lock <0x00000000d695bfe8> (a java.lang.Object)
        - locked <0x00000000d695bfd8> (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:748)
"Thread-0":
        at com.yingxs.deadlock.MustDeadLock.run(MustDeadLock.java:50)
        - waiting to lock <0x00000000d695bfd8> (a java.lang.Object)
        - locked <0x00000000d695bfe8> (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```



```java

/**
 * 两个人之间转账遇到死锁，打开注释，便会发生死锁
 * 1.需要获取两把锁
 * 2.获取两把锁成功，且余额大于0则扣除转出人，增加收款人余额，是原子操作
 * 3.顺序相反导致死锁
 */
public class TransferMonney implements Runnable {

    int flag = 1;

    static Account a = new Account(500);
    static Account b = new Account(500);


    public static void main(String[] args) throws InterruptedException {
        TransferMonney r1 = new TransferMonney();
        TransferMonney r2 = new TransferMonney();
        r1.flag = 1;
        r1.flag = 0;
        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("a的余额 "+a.balance);
        System.out.println("b的余额 "+b.balance);
    }

    @Override
    public void run() {
        if (flag == 1) {
            transferMoney(a,b,200);
        }
        if (flag == 0) {
            transferMoney(b,a,200);
        }
    }

    public static void transferMoney(Account from,Account to,int amount) {

        synchronized (from) {

//            try {
//                Thread.sleep(500);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }

            synchronized (to) {
                if (from.balance - amount < 0) {
                    System.out.println("余额不足，转账失败");
                }
                from.balance -= amount;
                to.balance += amount;
                System.out.println("成功转账"+amount+"元");
            }
        }

    }

    static class Account {
        int balance;

        public Account(int balance) {
            this.balance = balance;
        }
    }

}

```

多人随机转账，概率低但是危害大

```java

/**
 * 多人同时转账，依然很危险
 */
public class MultiTransferMoney {

    private static final int NUM_ACCOUNTS = 5000;
    private static final int NUM_MONEY = 1000;
    private static final int NUM_ITERATIONS = 1000000;
    private static final int NUM_THREADS = 20;

    public static void main(String[] args) {

        Random rnd = new Random();
        Account[] accounts = new Account[NUM_ACCOUNTS];
        for (int i = 0 ; i < accounts.length ; i++) {
            accounts[i] = new Account(NUM_MONEY);
        }

        class TransferThread extends Thread {
            @Override
            public void run() {
                for (int i = 0 ; i < NUM_ITERATIONS ; i++) {
                    int fromAcct = rnd.nextInt(NUM_ACCOUNTS);
                    int toAcct = rnd.nextInt(NUM_ACCOUNTS);
                    int amount = rnd.nextInt(NUM_MONEY);
                    TransferMonney.transferMoney(accounts[fromAcct],accounts[toAcct],amount);
                }
            }
        }

        for (int i = 0 ; i < NUM_THREADS ; i++) {
            new TransferThread().start();
        }

    }

}

```

### 死锁的四个必要条件

1. 互斥条件：一个资源同时只能被一个线程占用
2. 请求与保持条件：请求一把锁的同时，又保持着另一把锁，所以自身阻塞
3. 不剥夺条件
4. 循环等待条件

### 定位死锁

1. jstack pid 命令

2. ThreadMXBean

   ```java
   
   /**
    * 用ThreadMXBean检测死锁
    */
   public class ThreadMXBeanDetection implements Runnable {
       int flag = 1;
   
       static Object o1 = new Object();
       static Object o2 = new Object();
   
   
       public static void main(String[] args) throws InterruptedException {
           ThreadMXBeanDetection r1 = new ThreadMXBeanDetection();
           ThreadMXBeanDetection r2 = new ThreadMXBeanDetection();
           r1.flag = 1;
           r1.flag = 0;
   
           Thread t1 = new Thread(r1);
           Thread t2 = new Thread(r2);
           t1.start();
           t2.start();
           Thread.sleep(1000);
           ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
           long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();
           if (deadlockedThreads != null && deadlockedThreads.length > 0) {
               for (int i = 0 ; i < deadlockedThreads.length ; i++ ) {
                   ThreadInfo threadInfo = threadMXBean.getThreadInfo(deadlockedThreads[i]);
                   System.out.println("发现死锁："+threadInfo.getThreadName());
               }
           }
   
   
       }
   
       @Override
       public void run() {
   
           System.out.println("flag= "+flag);
   
           if (flag == 1) {
               synchronized (o1) {
                   try {
                       Thread.sleep(500);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
                   synchronized (o2) {
                       System.out.println("线程1成功拿到两把锁");
                   }
               }
   
           }
   
           if (flag == 0) {
               synchronized (o2) {
                   try {
                       Thread.sleep(500);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
                   synchronized (o1) {
                       System.out.println("线程2成功拿到两把锁");
                   }
               }
   
           }
   
       }
   }
   
   ```

### 修复死锁策略

> 线上发生死锁怎么办
>
> 线上问题都需要防患于未然，不造成损失几乎是不可能，如果线上发生死锁，第一步要保存现场，然后重启应用，保证程序正常运行，再排查死锁，修复升级 重新上线。

##### 避免策略

哲学家就餐的换手方案，转账换序方案

思路 : 避免相反的获取锁的顺序，实际上不在乎获取锁的顺序

通过hashCode来决定获取锁的顺序，冲突时需要“加时赛”

或使用实体主键决定获取锁的顺序

```java
public class TransferMonney implements Runnable {

    int flag = 1;

    static Account a = new Account(500);
    static Account b = new Account(500);
    static Object lock = new Object();


    public static void main(String[] args) throws InterruptedException {
        TransferMonney r1 = new TransferMonney();
        TransferMonney r2 = new TransferMonney();
        r1.flag = 1;
        r1.flag = 0;
        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("a的余额 "+a.balance);
        System.out.println("b的余额 "+b.balance);
    }

    @Override
    public void run() {
        if (flag == 1) {
            transferMoney(a,b,200);
        }
        if (flag == 0) {
            transferMoney(b,a,200);
        }
    }

    public static void transferMoney(Account from,Account to,int amount) {

        class Helper {
            public void transfer(){
                if (from.balance - amount < 0) {
                    System.out.println("余额不足，转账失败");
                }
                from.balance -= amount;
                to.balance += amount;
                System.out.println("成功转账"+amount+"元");
            }
        }

        int fromHash = System.identityHashCode(from);
        int toHash = System.identityHashCode(to);

        if ( fromHash < toHash ) {
            synchronized (from) {
                synchronized (to) {
                    new Helper().transfer();
                }
            }
        }
        else if ( fromHash > toHash ) {
            synchronized (to) {
                synchronized (from) {
                    new Helper().transfer();
                }
            }
        } else { // "加时赛" 避免哈希冲突
            synchronized (lock) {
                synchronized (to) {
                    synchronized (from) {
                        new Helper().transfer();
                    }
                }
            }
        }


    }

    static class Account {
        int balance;

        public Account(int balance) {
            this.balance = balance;
        }
    }

}

```

哲学家吃饭发生的死锁问题

```java
/**
 * 描述：演示哲学家就餐问题导致的死锁
 */
public class DiningPhilosophers  {

    public static class Philosopher implements Runnable {
        private Object leftChopstick;
        private Object rightChopstick;

        public Philosopher(Object lestChopstick, Object rightChopstick) {
            this.leftChopstick = lestChopstick;
            this.rightChopstick = rightChopstick;
        }

        @Override
        public void run() {

            try {
                while (true) {
                    doAction("思考");
                    synchronized (leftChopstick) {
                        doAction("拿起左边的筷子");
                        synchronized (rightChopstick) {
                            doAction("拿起右边的筷子-吃饭");
                            doAction("放下右边的筷子");
                        }
                        doAction("放下左边的筷子");
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        private void doAction(String action) throws InterruptedException {
            System.out.println(Thread.currentThread().getName()+" "+action);
            Thread.sleep((long ) Math.random()*10);
        }
    }


    public static void main(String[] args) {
        Philosopher[] philosophers = new Philosopher[5];
        Object[] chopsticks = new Object[philosophers.length];

        for (int i = 0 ; i < chopsticks.length ; i++) {
            chopsticks[i] = new Object();
        }

        for (int i = 0 ; i < philosophers.length ; i++) {
            Object leftChopstick = chopsticks[i];
            Object rightChopstick = chopsticks[(i+1) % chopsticks.length];
            philosophers[i] = new Philosopher(leftChopstick,rightChopstick);
            new Thread(philosophers[i],"哲学家"+(i+1)+"号").start();
        }
    }
}

```

解决策略：

1. 服务员检查(避免策略)
2. 改变一个哲学家拿叉子的顺序(避免策略)
3. 餐票(避免策略)
4. 领导调节(检测与恢复策略)

###### 改变一个哲学家拿叉子的顺序

```java
/**
 * 描述：演示哲学家就餐问题导致的死锁
 */
public class DiningPhilosophers  {

    public static class Philosopher implements Runnable {


        private Object leftChopstick;
        private Object rightChopstick;

        public Philosopher(Object lestChopstick, Object rightChopstick) {
            this.leftChopstick = lestChopstick;
            this.rightChopstick = rightChopstick;
        }

        @Override
        public void run() {

            try {
                while (true) {
                    doAction("思考");
                    synchronized (leftChopstick) {
                        doAction("拿起左边的筷子");
                        synchronized (rightChopstick) {
                            doAction("拿起右边的筷子-吃饭");
                            doAction("放下右边的筷子");
                        }
                        doAction("放下左边的筷子");
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        private void doAction(String action) throws InterruptedException {
            System.out.println(Thread.currentThread().getName()+" "+action);
            Thread.sleep((long ) Math.random()*10);
        }
    }


    public static void main(String[] args) {
        Philosopher[] philosophers = new Philosopher[5];
        Object[] chopsticks = new Object[philosophers.length];

        for (int i = 0 ; i < chopsticks.length ; i++) {
            chopsticks[i] = new Object();
        }

        for (int i = 0 ; i < philosophers.length ; i++) {
            Object leftChopstick = chopsticks[i];
            Object rightChopstick = chopsticks[(i+1) % chopsticks.length];

            if (i == philosophers.length-1) {
                philosophers[i] = new Philosopher(rightChopstick,leftChopstick);
            } else {
                philosophers[i] = new Philosopher(leftChopstick,rightChopstick);
            }
            new Thread(philosophers[i],"哲学家"+(i+1)+"号").start();

        }
    }

}

```





##### 检测与恢复策略

一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁

检测算法：锁的调用链路图

允许发生死锁，但是每次调用锁都记录，定期检查“锁的调用链路图”中是否存在环路，一旦检测到死锁，即可调用死锁恢复机制来恢复：

恢复方法1：进程终止，逐个终止线程，直到死锁消除

* 终止顺序
  * 优先级
  * 已占用资源，还需要的资源
  * 已运行时间

恢复方法2：资源抢占

​	1.把已经分发出去的锁收回来

​	2.让线程回退几步，这样就不用结束整个线程，成本较低

​	3. 可能同一线程一直被抢占，那就造成饥饿

##### 鸵鸟策略

### 实际工程中如何避免死锁

* 获取锁时设置超时时间

  * Lock中的tryLock,synchronized不具备尝试获取锁的能力

  * 造成超时的可能性很多：发生死锁，线程陷入死循环，线程执行的很慢

  * 获取锁失败：记录日志，报警，重启

    ```java
    /**
     * 描述：用tryLock来避免死锁
     */
    public class TryLockDeadlock implements Runnable {
    
        int flag = 1;
        static Lock lock1 = new ReentrantLock();
        static Lock lock2 = new ReentrantLock();
    
    
        public static void main(String[] args) {
    
            TryLockDeadlock r1 = new TryLockDeadlock();
            TryLockDeadlock r2 = new TryLockDeadlock();
            r1.flag = 1;
            r1.flag = 0;
            new Thread(r1).start();
            new Thread(r2).start();
    
        }
    
    
        @Override
        public void run() {
    
            try {
                for (int i = 0 ; i < 100 ; i++ ) {
                    if (flag == 1) {
    
                        if (lock1.tryLock(800, TimeUnit.MILLISECONDS)) {
                            System.out.println("线程1成功获取到了锁1");
                            Thread.sleep(new Random().nextInt(1000));
                            if (lock2.tryLock(800,TimeUnit.MILLISECONDS)) {
                                System.out.println("线程1成功获取到了锁2");
                                System.out.println("线程1成功获取到了两把锁");
                                lock2.unlock();
                                lock1.unlock();
                                break;
                            } else {
                                System.out.println("线程1获取锁2失败，已重试");
                                lock1.unlock();
                                Thread.sleep(new Random().nextInt(1000));
                            }
                        } else {
                            System.out.println("线程1获取锁1失败，已重试");
                        }
    
    
                    }
                    if (flag == 0) {
                        if (lock2.tryLock(3000, TimeUnit.MILLISECONDS)) {
                            System.out.println("线程2成功获取到了锁2");
                            Thread.sleep(new Random().nextInt(1000));
                            if (lock1.tryLock(3000,TimeUnit.MILLISECONDS)) {
                                System.out.println("线程2成功获取到了锁1");
                                System.out.println("线程2成功获取到了两把锁");
                                lock1.unlock();
                                lock2.unlock();
                                break;
                            } else {
                                System.out.println("线程2获取锁1失败，已重试");
                                lock2.unlock();
                                Thread.sleep(new Random().nextInt(1000));
                            }
                        } else {
                            System.out.println("线程2获取锁2失败，已重试");
                        }
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    ```

* 多使用并发类而不是自己设计锁

  * ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean等
  * 实际应用中java.util.concurrent.atomic十分有用，简单方便且效率比使用Lock更高
  * 多用并发集合少用同步集合，并发集合比同步集合的可扩展性更高
  * 并发场景用map，首先使用ConcurrentHashMap

* 尽量降低锁的使用粒度：用不同的锁而不是一个锁

* 如果能使用同步代码块，就不只用同步方法：自己指定锁对象和锁范围

* 给线程起一个有意义的名字

* 避免锁嵌套

* 分配资源前先看看能不能收回来：银行家算法

* 尽量不要几个功能使用同一把锁：专锁专用



### 其他活性故障

> 死锁是最常见的活跃性问题，不过除了刚才的死锁之外，还有一些类似的活跃性问题，会导致程序无法顺利执行，统称为活跃性问题

#### 活锁（LiveLock）

死锁：每个哲学家都拿着左手的0，永远都在等待右边的餐叉

活锁：在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉再等五分钟，又同时拿起这些餐叉

在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源

活锁虽然线程并没有阻塞，也始终都在运行，但是程序却得不到任何进展，因为线程始终重复做同样的事情

```java
/**
 * 演示活锁问题
 * 牛郎和织女发现对方饥饿，互相谦让，谁也没办法吃饭
 */
public class LiveLock {

    static class Spoon{
        private Diner owner;

        public Spoon(Diner owner) {
            this.owner = owner;
        }

        public Diner getOwner() {
            return owner;
        }

        public void setOwner(Diner owner) {
            this.owner = owner;
        }

        public synchronized  void use(){
            System.out.printf("%s 在吃饭",owner.name);
        }
    }

    static class Diner {
        private String name ;
        private boolean isHungry;

        public Diner(String name) {
            this.name = name;
            this.isHungry = true;
        }

        public void eatWith(Spoon spoon, Diner spouse) {
            while (isHungry) {
                if (spoon.owner != this) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    continue;
                }
                if (spouse.isHungry) {
                    System.out.println(name+": 亲爱的"+spouse.name+"你先吃吧");
                    spoon.setOwner(spouse);
                    continue;
                }
                spoon.use();
                isHungry = false;
                System.out.println(name+" : 我吃完了" );
                spoon.setOwner(spouse);
            }
        }

    }


    public static void main(String[] args) {
        Diner husband = new Diner("牛郎");
        Diner wife = new Diner("织女");

        Spoon spoon = new Spoon(husband);

        new Thread(new Runnable() {
            @Override
            public void run() {
                husband.eatWith(spoon,wife);
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                wife.eatWith(spoon,husband);
            }
        }).start();

    }


}

```

在以上程序中加入随机因素，让重试策略更加多远化

```java
...
Random random = new Random();
if (spouse.isHungry && random.nextInt(10) < 9 ) {
    System.out.println(name+": 亲爱的"+spouse.name+"你先吃吧");
    spoon.setOwner(spouse);
    continue;
}
...
```

##### 工程中的活锁实例：消息队列

> 如果消息处理失败，就放在队列开头重试，由于依赖服务除了问题，处理该消息一直失败
>
> 没阻塞但是程序无法继续

解决：放到队列尾部，重试限制

#### 饥饿

当线程需要某些资源（CPU），但是却始终得不到

比如线程的优先级设置过低，或者有某线程有锁同时无线循环从而不释放锁，后者某程序始终占用某文件的写锁

饥饿会导致响应性差

#### 常见问题

1. 必然死锁的例子？生产中什么场景下会发生死锁？
2. 发生死锁必须满足哪些条件？
3. 如何定位死锁？
4. 有哪些解决死锁的策略？
5. 经典的哲学家就餐问题？
6. 实际工程中如何避免死锁？
7. 什么是活跃性问题？活锁、饥饿和死锁有什么区别？









