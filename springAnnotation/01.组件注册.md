## 以往spring组件注册与使用

####  1.创建类Person.java

```java
public class Person {

	private String name;
	private Integer age;
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
    
	public Integer getAge() {
		return age;
	}

	public void setAge(Integer age) {
		this.age = age;
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}

	public Person() {
		super();
		// TODO Auto-generated constructor stub
	}

	public Person(String name, Integer age) {
		super();
		this.name = name;
		this.age = age;
	}
	

	
}

```

### 2.创建配置文件beans.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

	<bean id="person" class="com.yingxs.bean.Person"  >
		<property name="age"  value="18"></property>
		<property name="name"  value="zhangsan"></property>
	</bean>
</beans>

```

### 3.从容器中获取组件

```java
/**
* xml 方式获取bean
*/
@Test
public void test1() {
    // 根据配置文件创建容器
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
    Person bean = (Person)applicationContext.getBean("person");
    System.out.println(bean);
}
```



## 注解方式注册组件

### 1.创建类

### 2.创建配置类

```java
// 配置类 == 配置文件
/**
 * @Configuration 告诉spring这是一个配置类
 * 相当于这是一个配置文件一样
 * @author admin
 */
@Configuration
public class MainConfig {
	
	/**
	 * @Bean给容器注册一个Bean 
	 *  类型为返回值类型 id默认使用方法名作为id
	 *  
	 *  @Bean("person")指定组件的名字 也就是id
	 * @return
	 */
	@Bean("person")
	public Person person2() {
		return new Person("lisi",20);
	}

}

```

### 3.测试获取Bean

```java
/**
* 注解驱动获取bean
*/
@Test
public void test2() {
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
    Person bean = applicationContext.getBean(Person.class);
    System.out.println(bean);

    // 容器中该类型的所有组件id 也就是配置类中 返回该bean的方法名
    //但如果@bean中定义了该bean的name那就后者优先
    String[] namesForType = applicationContext.getBeanNamesForType(Person.class);
    for (String string : namesForType) {
        System.out.println(string);
    }

}
```





##  以往注解扫描

```xml
<!-- 包扫描、只要标注了@Controller、@Service、@Repository、@Component 都会被自动扫描加进容器中 -->
<context:component-scan base-package="com.yingxs"></context:component-scan>
```

## 注解驱动扫描

#### 1.配置类

```java
// 配置类 == 配置文件

//   
/**
 * @Configuration 告诉spring这是一个配置类
 * 相当于这是一个配置文件一样
 * 
 * 
 * @ComponentScan(value="com.yingxs")  配置包扫描  相当于
 * <context:component-scan base-package="com.yingxs"></context:component-scan>
 * 
 * 
 * excludeFilters  = Filter[] 扫描的时候，按什么规则，排除什么组件
 * 		type : 定义排除规则，按注解排除，还可以按类型、正则或自定义排除
		@ComponentScan(value="com.yingxs",includeFilters = {
				@Filter(type=FilterType.ANNOTATION,classes= {Controller.class})
		},useDefaultFilters = false)

 * includeFilters  = Filter[] 扫描的时候，按什么规则，只添加什么组件
 * 要和 useDefaultFilters = false 配置实用才能生效  禁用默认的扫描规则
 * 		type : 定义排除规则，按注解排除，还可以按类型、正则或自定义排除
 * 
 * 
 * @ComponentScans(    可用来配置多个扫描规则
			value = {
					@ComponentScan(value="com.yingxs",includeFilters = {
							@Filter(type=FilterType.ANNOTATION,classes= {Controller.class})
					},useDefaultFilters = false)
			} 
		)
 * 
 * 
 * @author admin
 */
@Configuration
@ComponentScans(
			value = {
					@ComponentScan(value="com.yingxs",includeFilters = {
							@Filter(type=FilterType.ANNOTATION,classes= {Controller.class})
					},useDefaultFilters = false)
			} 
		)
public class MainConfig {
	
	/**
	 * @Bean给容器注册一个Bean 
	 *  类型为返回值类型 id默认使用方法名作为id
	 *  
	 *  @Bean("person")指定组件的名字 也就是id
	 * @return
	 */
	@Bean("person")
	public Person person2() {
		return new Person("lisi",20);
	}

}
```

#### 4.测试容器中是否包含

```java
@Test
public void test3() {
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
    // 获取容器中所有bena的name
    String[] definitionNames = applicationContext.getBeanDefinitionNames();
    for (String string : definitionNames) {
        System.out.println(string);
    }


}
	
```

##### @ComponetScan

* value 指定要扫描的包
* excludeFilters = Fileter[]:指定扫描的时候按照什么规则排除那些组件
* includeFilters = Filter[]:指定扫描的时候只需要包含哪些组件
  * FilterType.ANNOTATION 按照注解
  * FilterType.ASSIGNABLE_TYPE 按照给定的类型
  * FilterType.ASPECTJ 使用ASPECTJ表达式
  * FilterType.REGX 使用正则指定
  * FilterType.CUSTOM :使用自定义规则

### @ComponetScan的自定义过滤规则

###  1.自定义过滤规则

```java

public class MyTypeFilter implements TypeFilter {

	/**
	 * metadataReader 读取到当前正在扫描的类的信息
	 * MetadataReaderFactory 可以获取到其他任何类的信息
	 */
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		// 获取当前类注解的信息
		AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
		// 获取当前正在扫描的类的类信息
		ClassMetadata classMetadata = metadataReader.getClassMetadata();
		 // 获取当前类资源(类路径)
		Resource resource = metadataReader.getResource();
		
		String className = classMetadata.getClassName();
		System.out.println("--->"+className);
		if (className.contains("er") ) {
			return true;
		}
		
		/**
		 * 该方法会扫描到该方法下所有的类，并通过自定义规则来决定是否加入容器
		 */
		
		
		return false;
	}

}

```

### 2.配置类

```java
@Configuration
@ComponentScans(
			value = {
					@ComponentScan(value="com.yingxs",includeFilters = {
							@Filter(type=FilterType.CUSTOM ,classes= {MyTypeFilter.class})
							
					},useDefaultFilters = false)
			} 
		)
public class MainConfig {
	
	/**
	 * @Bean给容器注册一个Bean 
	 *  类型为返回值类型 id默认使用方法名作为id
	 *  
	 *  @Bean("person")指定组件的名字 也就是id
	 * @return
	 */
	@Bean("person") //默认是单实例的
	public Person person2() {
		return new Person("lisi",20);
	}

}

```



## @Scope设置组件作用域

> @Bean注册的对象默认是单实例的，可通过@Scope设置作用域

* prototype 多实例的 IOC在启动的时候并不会调用方法创建独享，而是每次获取的时候才会调用方法创建对象
* singleton 单实例的  IOC容器在启动时就会调用方法创建对象方法ioc容器中，以后每次获取都是直接从容器(map.get())中拿
* request ：同义词请求创建一个实例
* session：同一个session创建一个实例