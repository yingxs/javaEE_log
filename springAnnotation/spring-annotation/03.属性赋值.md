## @Value赋值

- 基本数值
- 可以写SpEL表达式#{}
- 可以写${};取出配置文件中的值(在运行环境变量中的值)

```java
public class Person {

    @Value("张三")
    private String name;
    @Value("#{20-2}")
    private Integer age;

 ......

```

## @PropertySource

> 将配置文件中的k/v加载到环境变量中

```java
//使用@PropertySource读取外部配置文件中的k/v保存到运行的环境变量中，使用${}取出配置文件的值
@PropertySource(value = {"classpath:/person.properties"})
@Configuration
public class MainConfigOfPropertyValue {

    @Bean
    public Person person(){
        return new Person();
    }

}
```

properties

```properties
person.nickName=小三
```

Test

```java


public class IOCTest_PropertyValue {
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfPropertyValue.class);

    @Test
    public void test01(){

        printBeans(applicationContext);

        System.out.println("==================================");

        Person person = (Person)applicationContext.getBean("person");
        System.out.println(person);


        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        String property = environment.getProperty("person.nickName");
        System.out.println(property);

        applicationContext.close();

    }

    private void printBeans(AnnotationConfigApplicationContext applicationContext){
        String[] definitionNames = applicationContext.getBeanDefinitionNames();
        for(String name : definitionNames){
            System.out.println(name);
        }
    }

}


```



## @Autowired自动注入

>  自动装配,spring利用依赖注入(DI),完成对IOC容器中各个组件的依赖关系赋值

1. @Autowired:自动注入
   - 默认优先按照类型去容器中找对应的组件；=》applicationContext.getBean(BookDao.class);
   - 如果找到多个相同类型的组件，再讲属性的名称作为组件的id去容器查找；=》applicationContext.getBean("bookDao");
   - @Qualifier("bookDao") ;明确指定需要装配的组件Id，而不是使用属性名称
   - 自动装配默认一定要将属性装配好，没有找到就会抛出异常
   - @Autowired(required=false) 是否必须装配，默认是true,设置为false，当没有找到相应组件的时候该组件会被设置为null
   - @Primary：让spring自动装配的时候，默认首选的bean，也可以继续使用@Qualifier指定的bean，@Qualifier优先级大于@Primary

BookService.java

```java
@Service
public class BookService {

//    @Qualifier("bookDao")
    @Autowired(required = false)
    private BookDao bookDao2;

    public void print(){
        System.out.println(bookDao2);
    }

    @Override
    public String toString() {
        return "BookService{" +
                "bookDao=" + bookDao2 +
                '}';
    }
}

```

BookDao.java

```java

//IOC容器中名字默认是首字母小写
@Repository
public class BookDao {

    private String lable = "1";

    public String getLable() {
        return lable;
    }

    public void setLable(String lable) {
        this.lable = lable;
    }

    @Override
    public String toString() {
        return "BookDao{" +
                "lable='" + lable + '\'' +
                '}';
    }
}
```

主配置类

```java
@Configuration
@ComponentScan({"com.yingxs.service","com.yingxs.dao","com.yingxs.controller"})
public class MainConfigOfAutowired {

    @Primary
    @Bean("bookDao2")
    public BookDao bookDao(){
        BookDao bookDao = new BookDao();
        bookDao.setLable("2");
        return bookDao;
    }

}

```

Test

```java

public class IOCTest_Autowired {
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);


    @Test
    public void test01(){
        //1.创建IOC容器
        printBeans(applicationContext);
        System.out.println("容器创建完成...");

        BookService bookService = applicationContext.getBean(BookService.class);

        System.out.println(bookService);
        
//        BookDao bookDao = applicationContext.getBean(BookDao.class);
//        System.out.println(bookDao);

        //关闭容器
        applicationContext.close();

    }


    private void printBeans(AnnotationConfigApplicationContext applicationContext){
        String[] definitionNames = applicationContext.getBeanDefinitionNames();
        for(String name : definitionNames){
            System.out.println(name);
        }
    }
}

```

2.spring还支持使用@Resource(JSR250)和Inject(JSR330) [Java规范的注解]

 -  @Resource:可以和@Autowired一样实现自动装配功能；默认是按照组件名称进行装配的；不支持@Primary优先；不支持@Autowired(reqiured=false)
 -  @Inject: 使用前需要先导入依赖，和@Autowired功能一样，支持@Primary优先；不支持@Autowired(reqiured=false)
 -  @Autowired是spring定义的；@Resource、@Inject都是Java规范

```xml
<dependency>
    <groupId>javax.inject</groupId>
    <artifactId>javax.inject</artifactId>
    <version>1</version>
</dependency>
```





## @Autowired的其他使用方式

> @Autowired能够使用在构造器、参数、方法、属性；

- 标注在方法位置

如下实例，Boss对象中有个Car属性，car组件通过set方法从IOC'容器中注入

Boss.java

```java
@Component
public class Boss {

    private Car car;


    public Car getCar() {
        return car;
    }

    //标注在方法上，spring容器在创建当前Boss对象的时候，就会调用该方法完成赋值
    //方法使用的参数，自定义类型的值从ioc容器中获取
    @Autowired
    public void setCar(Car car) {
        this.car = car;
    }


    @Override
    public String toString() {
        return "Boss{" +
                "car=" + car +
                '}';
    }
}

```

- 标注在构造器位置,构造器中要使用的组件也都是从容器中获取的

```java
@Component
public class Boss {

    private Car car;


    @Autowired
    public Boss(Car car){
        this.car=car;
        System.out.println("Boss.....有参构造器");
    }

```

- 参数位置：构造器参数和set参数都可以



##### PS：如果组件只有一个有参构造器参数的@Autowired可以省略，参数位置的组件还是可以自动从容器中注入

