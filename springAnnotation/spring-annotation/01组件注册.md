## @Configuration & @Bean

@Configuration : 声明一个类为配置类

@Bean ： 向容器中添加组件

#### 传统开发

bean.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="person" class="com.yingxs.bean.Person" >
        <property name="age" value="18"></property>
        <property name="name" value="yingxs"></property>
    </bean>

</beans>
```



perosn.java

```java
public class Person {

    private String name;
    private Integer age;

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

```

Test

```java
public class MainTest {

    public static void main(String[] args) {
       ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
       Person person = (Person)applicationContext.getBean("person");
       System.out.println(person);

    }
    
}

```



#### 注解驱动开发

MainConfig.java

```java
//配置类==配置文件
@Configuration       //告诉spring 这是一个配置类
public class MainConfig {

    //给容器中注册一个bean;类型为返回值类型，id为默认方法名，也可通过注解指定
    @Bean("person")
    public Person person99(){
        return new Person("yingxs",17);
    }
}

```

Test

```java
 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
        Person person = (Person)applicationContext.getBean(Person.class);
        System.out.println(person);


        String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class);
        for (String name : beanNamesForType ) {
            System.out.println(name);
        }
```



## 组件注册包扫描

#### 传统开发

```xml

    <context:component-scan base-package="com.yingxs"></context:component-scan>
```

只要是标注了@Controller、@Service、@Repository、@Component等注解，都会被自动加入到IOC容器

#### 注解驱动

@ComponentScan @ComponentScans

- value :指定要扫描的包
- excludeFilters :指定排除规则以及类型
- includeFilters :扫描时只引入，useDefaultFilters = false才能生效

```java

public class IOCTest {

    @Test
    public void test01(){
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
        String[] definitionNames = applicationContext.getBeanDefinitionNames();
        //查看IOC容器中的所有组件
        for (String name:definitionNames) {
            System.out.println(name);
        }
    }
}

```

#### 自定义TypeFilter指定过滤规则

FilterType.ANNOTATION  :按照注解

FilterTYpe.ASSIGNABLE_TYPE ：按照给定类型

- 例如

```java
//配置类==配置文件
@Configuration       //告诉spring 这是一个配置类
@ComponentScan(value="com.yingxs",includeFilters = {
        @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Controller.class}),
        @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE,classes = {Service.class})
},useDefaultFilters = false)
public class MainConfig {

    //给容器中注册一个bean;类型为返回值类型，id为方法名
    @Bean("person")
    public Person person99(){
        return new Person("yingxs",17);
    }
}

//将包含 Controller和Service组件


```



FilterType.ASPECTJ ：使用ASPECTJ表达式

FilterType.REGEX：正则表达式指定

FilterType.CUSTOM：指定规则



自定义过滤规则需要实现TypeFilter接口

```java

public class MyTypeFilter implements TypeFilter {

    /**
     * 
     * @param metadataReader 读取的当前正在扫描的类
     * @param metadataReaderFactory 获取到任何类的信息
     * @return
     * @throws IOException
     */
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {

        //获取当前类的注解信息
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();

        //获取当前正在扫描的类的类信息
        ClassMetadata classMetadata = metadataReader.getClassMetadata();

        //获取当前类的资源信息
        Resource resource = metadataReader.getResource();

        String className = classMetadata.getClassName();
        System.out.println("--->"+className);


        if(className.contains("er")){
            return true;
        }

        return false;
    }
    
}

```

```java

//配置类==配置文件
@Configuration       //告诉spring 这是一个配置类
@ComponentScan(value="com.yingxs",includeFilters = {
        @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {MyTypeFilter.class})
},useDefaultFilters = false)
public class MainConfig {

    //给容器中注册一个bean;类型为返回值类型，id为方法名
    @Bean("person")
    public Person person99(){
        return new Person("yingxs",17);
    }
}

```

## @Scope 作用域

- prototype 多实例，IOC启动时并不会创建对象，而是每次获取的时候才会创建对象
- singleton 单实例(默认)，IOC容器启动就会创建放入容器中，以后每次获取都是直接从容器中拿
- request 同一个请求创建一个实例
- session 同一个session创建一个实例



## @Lazy 懒加载

单实例的bean，默认在容器启动的时候创建对象，懒加载：容器启动的时候不创建对象，第一次使用Bean创建对象，并初始化



## @Conditional 条件注册

@Conditional({Condition})  按照一定的条件判断，满足条件才给容器中注册bean，如果该注解标注在某个类上，表示类中组件统一设置注册条件，满足条件这个类中的配置的所有bean注册才能生效

@Conditional 注解中需要传入Condition数组，即判断条件；实现Condition接口

```java
 /**
     * @Conditional({Condition}) : 按照一定的条件进行判断，满足条件给容器中注册bean
     * 如果系统是window 注册bill
     * 如果系统是linux 注册linus
     */
    @Conditional({WindowCondition.class})
    @Bean("bill")
    public Person person01(){
        return new Person("Bill Gates",62);
    }

    @Conditional({LinuxCondition.class})
    @Bean("linus")
    public Person person02(){
        return new Person("linus",48);
    }

```

- 两个Condition

  ```java
  //判断操系统是否是linux
  public class LinuxCondition implements Condition {
      /**
       *
       * @param conditionContext 判断条件能使用的上下文(环境)
       * @param annotatedTypeMetadata 注释信息
       * @return
       */
      public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
          //判断是否是linux系统
          //1.获取到ioc使用的beanfactory
          ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();
          //2.获取到类加载器
          ClassLoader classLoader = conditionContext.getClassLoader();
          //3.获取当前环境信息
          Environment environment = conditionContext.getEnvironment();
          //4.获取bean定义的注册类
          BeanDefinitionRegistry registry = conditionContext.getRegistry();
  
          //判断容器中bean的注册情况，也可以给容器中注册bean
          boolean defintion = registry.containsBeanDefinition("person");
  
          String property = environment.getProperty("os.name");
          if(property.contains("linux")){
              return true;
          }
  
          return false;
      }
  }
  
  
  ```

  ```java
  //判断操作系统是否是windows
  public class WindowCondition implements Condition{
      /**
       *
       * @param conditionContext 判断条件能使用的上下文(环境)
       * @param annotatedTypeMetadata 注释信息
       * @return
       */
      public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
          Environment environment = conditionContext.getEnvironment();
          String property = environment.getProperty("os.name");
          if (property.contains("Windows")) {
              return true;
          }
          return false;
      }
  }
  
  ```


Test

```java
@Test
    public void test03(){
        String[] namesForType = applicationContext.getBeanNamesForType(Person.class);
        //获取运行环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        //动态获取环境变量中的值
        //获取操作系统名称
        String property = environment.getProperty("os.name");
        System.out.println(property);

        for(String name : namesForType){
            System.out.println(name);
        }
        System.out.println("===========");

        Map<String, Person> persons = applicationContext.getBeansOfType(Person.class);
        System.out.println(persons);

    }
```



## @Import 快速导入

至此，我们已经学习了给容器中添加组件有以下几种方式：

1. 包扫描+组件标注注解(@Controller/@Service/@Repository/@Component) [我们自己写的类]
2. @Bean [导入的第三方包里面的组件]
3. @Import [快速的给容器中导入一个组件]
   1. @Import(要导入到容器中的组件)：容器就会自动注册这个组件，id默认是全类
   2. ImportSelector：返回需要导入的组件的全类名数组
   3. ImportBeanDefinitionRegistrar:手动注册bean到容器中
4. 使用spring提供的FactoryBean(工厂Bean)
   1. 默认获取的是工厂Bean调用getObject创建的对象
   2. 要获取工厂Bean本身,要给id前面加一个&前缀

```java
@Configuration
@Import({Color.class, Red.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class})
//导入组件，id默认是组件的全类名
public class MainConfig02 {
	.....
}
```

MyImportSelector.java

```java

//自定义逻辑返回需要导入的组件
public class MyImportSelector implements ImportSelector {

    /**
     * 返回值就是导入到容器中的组件全类名
     * @param annotationMetadata 当前标注Import注解的类的所有注解信息
     * @return
     */
    public String[] selectImports(AnnotationMetadata annotationMetadata) {
        return new String[]{"com.yingxs.bean.Blue","com.yingxs.bean.Yellow"};
    }
}

```

MyImportBeanDefinitionRegistrar.java

```java

public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

    /**
     *
     * @param importingClassMetadata 当前类的注解信息
     * @param registry BeanDefinition注册类
     *                 把所有需要添加到容器中的bean;调用
     *                 BeanDefinitionRegistry.registerBeanDefinition手工注册进来
     *
     */
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        boolean red = registry.containsBeanDefinition("com.yingxs.bean.Red");
        boolean blue = registry.containsBeanDefinition("com.yingxs.bean.Blue");

        if(red && blue){
            //指定bean的定义信息
            RootBeanDefinition beanDefinition = new RootBeanDefinition(RainBow.class);
            //注册一个Bean,指定bean名
            registry.registerBeanDefinition("rainBow",beanDefinition);
        }

    }
}

```



Test

```java
 public class IOCTest {
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig02.class);

    @Test
    public void testImport(){
        printBeans(applicationContext);
        Blue bean = applicationContext.getBean(Blue.class);
        System.out.println(bean);
    }

    private void printBeans(AnnotationConfigApplicationContext applicationContext){
        String[] definitionNames = applicationContext.getBeanDefinitionNames();
        for(String name : definitionNames){
            System.out.println(name);
        }
    }
```



## FactoryBean

使用spring提供的FactoryBean(工厂Bean)

1. 默认获取的是工厂Bean调用getObject创建的对象
2. 要获取工厂Bean本身,要给id前面加一个&前缀

```java
//创建一个spring定义的FacrotyBean
public class ColorFactoryBean implements FactoryBean<Color> {

    //返回一个Color对象，这个对象会添加到容器中
    public Color getObject() throws Exception {
        System.out.println("ColorFactoryBean.....getObject.....");
        return new Color();
    }

    public Class<?> getObjectType() {
        return Color.class;
    }

    //是单例吗？
    // true代表是单例，在容器中保存一份，
    // fasle代表是多实例，每次获取都会创建一个新的对象
    public boolean isSingleton() {
        return true;
    }
}

```

配置类

```java


    @Bean
    public ColorFactoryBean colorFactoryBean(){
        return new ColorFactoryBean();
    }
```

Test

```java
public class IOCTest {
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig02.class);

    @Test
    public void testImport(){
        printBeans(applicationContext);
        Blue bean = applicationContext.getBean(Blue.class);
        System.out.println(bean);

        //工厂Bean获取的是调用getObject创建的对象
        Object bean2 = applicationContext.getBean("colorFactoryBean");
        Object bean3 = applicationContext.getBean("colorFactoryBean");
        System.out.println("bean的类型："+bean2.getClass());
        System.out.println(bean2==bean3);

        //获取工厂Bean本身
        Object bean4 = applicationContext.getBean("&colorFactoryBean");
        System.out.println(bean4.getClass());
    }

    private void printBeans(AnnotationConfigApplicationContext applicationContext){
        String[] definitionNames = applicationContext.getBeanDefinitionNames();
        for(String name : definitionNames){
            System.out.println(name);
        }
    }
}
```

