## @Configuration & @Bean

@Configuration : 声明一个类为配置类

@Bean ： 向容器中添加组件

#### 传统开发

bean.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="person" class="com.yingxs.bean.Person" >
        <property name="age" value="18"></property>
        <property name="name" value="yingxs"></property>
    </bean>

</beans>
```



perosn.java

```java
public class Person {

    private String name;
    private Integer age;

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

```

Test

```java
public class MainTest {

    public static void main(String[] args) {
       ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
       Person person = (Person)applicationContext.getBean("person");
       System.out.println(person);

    }
    
}

```



#### 注解驱动开发

MainConfig.java

```java
//配置类==配置文件
@Configuration       //告诉spring 这是一个配置类
public class MainConfig {

    //给容器中注册一个bean;类型为返回值类型，id为默认方法名，也可通过注解指定
    @Bean("person")
    public Person person99(){
        return new Person("yingxs",17);
    }
}

```

Test

```java
 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
        Person person = (Person)applicationContext.getBean(Person.class);
        System.out.println(person);


        String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class);
        for (String name : beanNamesForType ) {
            System.out.println(name);
        }
```



## 组件注册包扫描

#### 传统开发

```xml

    <context:component-scan base-package="com.yingxs"></context:component-scan>
```

只要是标注了@Controller、@Service、@Repository、@Component等注解，都会被自动加入到IOC容器

#### 注解驱动

@ComponentScan @ComponentScans

- value :指定要扫描的包
- excludeFilters :指定排除规则以及类型
- includeFilters :扫描时只引入，useDefaultFilters = false才能生效

```java

public class IOCTest {

    @Test
    public void test01(){
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
        String[] definitionNames = applicationContext.getBeanDefinitionNames();
        //查看IOC容器中的所有组件
        for (String name:definitionNames) {
            System.out.println(name);
        }
    }
}

```

#### 自定义TypeFilter指定过滤规则

FilterType.ANNOTATION  :按照注解

FilterTYpe.ASSIGNABLE_TYPE ：按照给定类型

- 例如

```java
//配置类==配置文件
@Configuration       //告诉spring 这是一个配置类
@ComponentScan(value="com.yingxs",includeFilters = {
        @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Controller.class}),
        @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE,classes = {Service.class})
},useDefaultFilters = false)
public class MainConfig {

    //给容器中注册一个bean;类型为返回值类型，id为方法名
    @Bean("person")
    public Person person99(){
        return new Person("yingxs",17);
    }
}

//将包含 Controller和Service组件


```



FilterType.ASPECTJ ：使用ASPECTJ表达式

FilterType.REGEX：正则表达式指定

FilterType.CUSTOM：指定规则



自定义过滤规则需要实现TypeFilter接口

```java

public class MyTypeFilter implements TypeFilter {

    /**
     * 
     * @param metadataReader 读取的当前正在扫描的类
     * @param metadataReaderFactory 获取到任何类的信息
     * @return
     * @throws IOException
     */
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {

        //获取当前类的注解信息
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();

        //获取当前正在扫描的类的类信息
        ClassMetadata classMetadata = metadataReader.getClassMetadata();

        //获取当前类的资源信息
        Resource resource = metadataReader.getResource();

        String className = classMetadata.getClassName();
        System.out.println("--->"+className);


        if(className.contains("er")){
            return true;
        }

        return false;
    }
    
}

```

```java

//配置类==配置文件
@Configuration       //告诉spring 这是一个配置类
@ComponentScan(value="com.yingxs",includeFilters = {
        @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {MyTypeFilter.class})
},useDefaultFilters = false)
public class MainConfig {

    //给容器中注册一个bean;类型为返回值类型，id为方法名
    @Bean("person")
    public Person person99(){
        return new Person("yingxs",17);
    }
}

```

## @Scope 作用域

- prototype 多实例，IOC启动时并不会创建对象，而是每次获取的时候才会创建对象
- singleton 单实例(默认)，IOC容器启动就会创建放入容器中，以后每次获取都是直接从容器中拿
- request 同一个请求创建一个实例
- session 同一个session创建一个实例